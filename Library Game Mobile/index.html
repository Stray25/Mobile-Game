<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Allow fullscreen display on mobile devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes">
  <title>Library Manager Idle Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      /* set full page background image */
      background-image: url('library_background.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
    }
    h1 {
      margin-bottom: 0;
    }
    #stats {
      margin: 15px 0;
      font-size: 18px;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    .upgrade {
      display: block;
      margin-top: 10px;
    }
    #log {
      margin-top: 20px;
      max-width: 400px;
      text-align: left;
      font-size: 14px;
    }

    /* Container styling to reduce white space and add card-like appearance */
    #gameContainer {
      background-color: rgba(255, 255, 255, 0.9);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      max-width: 600px;
      width: 100%;
      margin-top: 20px;
    }
    #achievements {
      margin-top: 20px;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
    #achievements h3 {
      margin-bottom: 5px;
    }
    #achievementsList {
      list-style-type: none;
      padding-left: 0;
    }
    #achievementsList li {
      padding: 4px 0;
      font-size: 14px;
    }

    /* Simple progress bar for next achievement */
    #progressContainer {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 8px;
      height: 12px;
      margin-top: 10px;
      overflow: hidden;
    }
    #progressBar {
      height: 100%;
      width: 0%;
      background-color: #6c63ff;
      border-radius: 8px;
      transition: width 0.3s ease;
    }

    .achievement-unlocked {
      color: #2c7a7b;
      font-weight: bold;
    }
    .achievement-locked {
      color: #999;
    }

    /* Daily quest progress bar */
    .quest-progress-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 6px;
      height: 10px;
      overflow: hidden;
      margin-top: 4px;
    }
    .quest-progress-bar {
      height: 100%;
      width: 0%;
      background-color: #f9a825;
      border-radius: 6px;
      transition: width 0.2s ease;
    }
    .quest-item {
      margin-bottom: 8px;
    }
    .quest-item button {
      margin-left: 8px;
      font-size: 12px;
      padding: 4px 8px;
    }

    /* Theme options styling */
    .theme-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(240, 240, 240, 0.7);
      padding: 6px 10px;
      border-radius: 8px;
    }
    .theme-option.disabled {
      opacity: 0.6;
    }
    .theme-option button {
      font-size: 12px;
      padding: 4px 8px;
    }

    /* Animation for book icon when cataloging */
    @keyframes bookBounce {
      0% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(-5deg) scale(1.05); }
      50% { transform: rotate(5deg) scale(1.05); }
      75% { transform: rotate(-3deg) scale(1.03); }
      100% { transform: rotate(0deg) scale(1); }
    }
    .image-animate {
      animation: bookBounce 0.4s ease;
    }
  </style>
    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
</head>
<body>
  <h1>Library Manager</h1>
  <div id="gameContainer">
  <!-- Decorative book stack image to enhance library theme -->
  <div id="imageContainer" style="text-align:center;">
    <img id="bookIcon" src="book_stack.png" alt="Stack of Books" style="width:120px;height:auto;margin-bottom:15px;">
  </div>
  <div id="stats">
    <div>Books: <span id="coins">0</span></div>
    <div>Books per tap: <span id="clickValue">1</span></div>
    <div>Books per second: <span id="passive">0</span></div>
    <div>Prestige Level: <span id="prestigeDisplay">0</span></div>
    <div>Boosters: <span id="boosterCount">0</span></div>
    <div>Gems: <span id="gemCount">0</span></div>
      <div>All‑time Books: <span id="totalBooks">0</span></div>
  </div>
  <button id="clickBtn">Catalog Book</button>
  <button id="upgradeClick" class="upgrade">Improve Cataloging Tools (+1 book/tap) — Cost: <span id="upgradeCost">10</span></button>
  <button id="hireWorker" class="upgrade">Hire Librarian (+0.5 books/sec) — Cost: <span id="workerCost">25</span></button>
  <button id="expandRoom" class="upgrade">Expand Reading Room (+1 book/sec) — Cost: <span id="expandCost">50</span></button>
  <button id="buyManuscript" class="upgrade">Acquire Rare Manuscripts (+3 books/tap) — Cost: <span id="manuscriptCost">30</span></button>
  <button id="digitizeArchives" class="upgrade">Digitize Archives (+5 books/tap) — Cost: <span id="digitizeCost">100</span></button>
  <button id="hostEvent" class="upgrade">Host Author Event (+2 books/sec) — Cost: <span id="eventCost">150</span></button>
  <button id="openWing" class="upgrade">Open New Wing (+2 books/tap, +3 books/sec) — Cost: <span id="wingCost">250</span></button>
  <button id="prestigeBtn" class="upgrade" style="display:none;">Renovate Library (Prestige)</button>
  <button id="getBooster" class="upgrade">Watch Ad for Booster</button>
  <button id="useBooster" class="upgrade">Use Booster (x2 for 2m)</button>
  <button id="dailyReward" class="upgrade">Claim Daily Reward</button>
  <div id="achievements">
    <h3>Achievements</h3>
    <ul id="achievementsList"></ul>
    <!-- Label for the progress bar -->
    <div id="progressText" style="font-size:12px;margin-top:8px;color:#555;">Progress to next achievement:</div>
    <div id="progressContainer"><div id="progressBar"></div></div>
  </div>
  <!-- Daily quests section -->
  <div id="quests" style="margin-top:20px;">
    <h3>Daily Quests</h3>
    <ul id="questsList" style="list-style-type:none;padding-left:0;font-size:14px;"></ul>
  </div>
  <!-- Themes customization section -->
  <div id="themes" style="margin-top:20px;">
    <h3>Library Themes</h3>
    <div id="themesOptions" style="display:flex;flex-direction:column;gap:6px;"></div>
  </div>
  <!-- Leaderboard placeholder section -->
  <div id="leaderboard" style="margin-top:20px;">
    <h3>Leaderboard</h3>
    <ol id="leaderboardList" style="padding-left:20px;font-size:14px;"></ol>
    <!-- Social: Friend features -->
    <div id="friendFeatures" style="margin-top:10px;font-size:13px;">
      <div>Your code: <span id="playerCode"></span></div>
      <div style="margin-top:6px;">
        <input id="friendCodeInput" type="text" placeholder="Enter friend code" style="width:60%;padding:4px;" />
        <button id="addFriendBtn" style="padding:4px 8px;margin-left:4px;">Add Friend</button>
      </div>
    </div>
  </div>
  <!-- Store and monetization section -->
  <div id="store" style="margin-top:20px;">
    <h3>Store</h3>
    <!-- Purchase boosters with real money (placeholder). In a live game this would
         integrate with a payment SDK; here it simply logs a message. -->
    <button id="buyBoosterPack" class="upgrade">Buy Booster Pack (x5 boosters) – $1.99</button>
    <!-- Remove ads permanently. This would call the platform's IAP API in a real
         implementation. -->
    <button id="removeAdsPaidBtn" class="upgrade">Remove Ads ($2.99)</button>
    <!-- Buy premium currency (gems) to spend on special items. Not implemented
         fully but illustrates a common monetization option. -->
    <button id="buyGems" class="upgrade">Buy Gems (100) – $4.99</button>
  </div>

  <!-- End‑game content: special collections and limited events -->
  <div id="endgame" style="margin-top:20px;">
    <h3>Special Collections & Events</h3>
    <!-- Special collections provide permanent global income multipliers. Costs and
         effects scale dramatically, offering late‑game objectives. -->
    <div id="specialCollections">
      <button id="buyAncientTome" class="upgrade">Acquire Ancient Tome (×2 global income) — Cost: <span id="ancientTomeCost">5000</span></button>
      <button id="buyMythicScroll" class="upgrade">Acquire Mythic Scroll (×5 global income) — Cost: <span id="mythicScrollCost">20000</span></button>
      <button id="buyLegendaryCodex" class="upgrade">Acquire Legendary Codex (×10 global income) — Cost: <span id="legendaryCodexCost">100000</span></button>

      <!-- New end‑game item: Infinite Shelf dramatically increases global income and
           provides a long‑term goal for dedicated players -->
      <button id="buyInfiniteShelf" class="upgrade">Acquire Infinite Shelf (×20 global income) — Cost: <span id="infiniteShelfCost">200000</span></button>
    </div>
    <!-- Time‑limited events give temporary boosts. Players can join for large
         multipliers and special rewards. -->
    <div id="events" style="margin-top:10px;">
      <button id="startEventBtn" class="upgrade">Host Book Festival (5 min ×3 income)</button>
      <div id="eventStatus" style="font-size:14px;margin-top:6px;color:#444;"></div>
    </div>

    <!-- Inventory display for special collection items -->
    <div id="inventory" style="margin-top:10px;">
      <h4>Collection Inventory</h4>
      <ul id="inventoryList" style="padding-left:20px;font-size:14px;"></ul>
    </div>
  </div>

  <!-- Real-time leaderboard placeholder removed. Leaderboard is unified into
       the main leaderboard section. -->
  <div id="log"></div>
  </div> <!-- end gameContainer -->

  <script>
    // Idle game variables
    let coins = 0; // Books collected
    let clickValue = 1; // Books per tap
    let passiveIncome = 0; // Books per second generated by librarians
    let upgradeCost = 10; // Cost to improve cataloging tools
    let workerCost = 25; // Cost to hire a librarian

    // New upgrade costs for library-themed progression
    let expandRoomCost = 50; // Cost to expand the reading room
    let manuscriptCost = 30; // Cost to acquire rare manuscripts

    // Additional upgrades: digitize archives, host event, open a new wing
    let digitizeCost = 100;
    let eventCost = 150;
    let wingCost = 250;

    // Achievement data: threshold and name
    const achievementsData = [
      { threshold: 100, name: 'Local Library', description: 'Collect 100 books.', unlocked: false },
      { threshold: 500, name: 'Community Favorite', description: 'Collect 500 books.', unlocked: false },
      { threshold: 1000, name: 'Regional Archive', description: 'Collect 1,000 books.', unlocked: false },
      { threshold: 5000, name: 'National Library', description: 'Collect 5,000 books.', unlocked: false }
      ,{ threshold: 10000, name: 'State Library', description: 'Collect 10,000 books.', unlocked: false }
      ,{ threshold: 50000, name: 'Library of Alexandria', description: 'Collect 50,000 books.', unlocked: false }
    ];

    // Prestige system variables
    // When players accumulate enough books, they can reset progress (renovate the
    // library) to gain a permanent multiplier on future earnings. This keeps
    // late‑game play meaningful and is a common mechanic in successful idle
    // clickers【973594451637787†L124-L154】. The multiplier grows with each prestige level.
    let prestigeLevel = 0;
    let prestigeMultiplier = 1;
    const prestigeThreshold = 10000; // books needed to renovate library

    // Booster system variables
    // Boosters simulate rewarded ads; watching an ad grants a booster that
    // temporarily doubles production. When used, boosters encourage players to
    // revisit the game frequently and mirror monetization tactics seen in top
    // idle titles【119958854742217†L147-L155】.
    let boosterCount = 0;
    let boosterActive = false;
    let boosterEndTime = 0;
    const boosterDuration = 120; // seconds

    // Daily reward system variables
    let lastDailyRewardTime = 0;
    const dailyRewardAmount = 500; // reward for daily login

    // Premium currency and purchase flags
    let gems = 0;
    let removeAdsPurchased = false;

    // Special collection variables. Each item multiplies global earnings.
    let globalBonusMultiplier = 1;
    const specialItemCounts = {
      ancientTome: 0,
      mythicScroll: 0,
      legendaryCodex: 0
      ,infiniteShelf: 0
    };
    // Costs for special items
    const specialItemCosts = {
      ancientTome: 5000,
      mythicScroll: 20000,
      legendaryCodex: 100000
      ,infiniteShelf: 200000
    };
    // Multipliers for special items
    const specialItemMultipliers = {
      ancientTome: 2,
      mythicScroll: 5,
      legendaryCodex: 10
      ,infiniteShelf: 20
    };

    // Event variables for time‑limited boosts
    let eventActive = false;
    let eventEndTime = 0;
    const eventMultiplier = 3;
    const eventDuration = 5 * 60; // 5 minutes in seconds

    // Limit the number of events per day to encourage strategic use
    let eventUsesToday = 0;
    const maxEventUsesPerDay = 2;
    let lastEventResetTime = 0;

    // Global competitor data. These players simulate a worldwide leaderboard.
    let globalPlayers = [
      { name: 'Bibliophile01', score: 120000 },
      { name: 'ArchiveMaster', score: 95000 },
      { name: 'TomeCollector', score: 70000 },
      { name: 'ShelfSurfer', score: 45000 }
    ];

    // Track last save time for offline earnings
    let lastSaveTime = Date.now();

    // Track all‑time books collected. This accumulates total books earned
    // across runs and is used for leaderboard ranking. It persists
    // independently of prestige resets and spending.
    let totalBooks = 0;

    /**
     * Get the total multiplier applied to book gains. This includes
     * contributions from prestige levels, active boosters, special
     * collections, and events.
     */
    function getTotalMultiplier() {
      return prestigeMultiplier * (boosterActive ? 2 : 1) * globalBonusMultiplier * (eventActive ? eventMultiplier : 1);
    }

    // DOM elements
    const coinsEl = document.getElementById('coins');
    const clickValueEl = document.getElementById('clickValue');
    const passiveEl = document.getElementById('passive');
    const upgradeCostEl = document.getElementById('upgradeCost');
    const workerCostEl = document.getElementById('workerCost');
    const expandCostEl = document.getElementById('expandCost');
    const manuscriptCostEl = document.getElementById('manuscriptCost');
    const achievementsListEl = document.getElementById('achievementsList');
    const clickBtn = document.getElementById('clickBtn');
    const upgradeClickBtn = document.getElementById('upgradeClick');
    const hireWorkerBtn = document.getElementById('hireWorker');
    const expandRoomBtn = document.getElementById('expandRoom');
    const buyManuscriptBtn = document.getElementById('buyManuscript');
    const digitizeBtn = document.getElementById('digitizeArchives');
    const hostEventBtn = document.getElementById('hostEvent');
    const openWingBtn = document.getElementById('openWing');

    const digitizeCostEl = document.getElementById('digitizeCost');
    const eventCostEl = document.getElementById('eventCost');
    const wingCostEl = document.getElementById('wingCost');
    const logEl = document.getElementById('log');

    // Daily quests variables
    let dailyQuests = [];
    let lastQuestResetTime = 0;
    let lastQuestCoins = 0;
    const questsListEl = document.getElementById('questsList');

    // Theme customization variables
    // Each theme can specify a cost in books or gems. If gemsCost > 0 the
    // purchase will use gems instead of books. This gives players a reason
    // to buy gems via the store and spend them on premium cosmetics.
    const themes = {
      classic: {
        name: 'Classic',
        cost: 0,
        gemsCost: 0,
        bg: 'library_background.png',
        containerBg: 'rgba(255, 255, 255, 0.9)',
        textColor: '#333',
        accentColor: '#6c63ff'
      },
      modern: {
        name: 'Modern',
        cost: 0,
        gemsCost: 20,
        bg: 'modern_background.png',
        containerBg: 'rgba(245, 245, 245, 0.9)',
        textColor: '#222',
        accentColor: '#0288d1'
      },
      fantasy: {
        name: 'Fantasy',
        cost: 0,
        gemsCost: 40,
        bg: 'fantasy_background.png',
        containerBg: 'rgba(255, 255, 255, 0.85)',
        textColor: '#4527a0',
        accentColor: '#ab47bc'
      }
    };
    let ownedThemes = { classic: true };
    let currentTheme = 'classic';
    const themesOptionsEl = document.getElementById('themesOptions');

    // Leaderboard placeholder variables
    let leaderboardData = [
      { name: 'Alex', score: 80000 },
      { name: 'Sam', score: 50000 },
      { name: 'Jordan', score: 20000 },
      { name: 'Taylor', score: 10000 }
    ];
    const leaderboardListEl = document.getElementById('leaderboardList');

    // Social friend system variables
    let playerCode = '';
    let friendsList = [];
    const playerCodeEl = document.getElementById('playerCode');
    const friendCodeInput = document.getElementById('friendCodeInput');
    const addFriendBtn = document.getElementById('addFriendBtn');

    const prestigeBtn = document.getElementById('prestigeBtn');
    const boosterBtn = document.getElementById('getBooster');
    const useBoosterBtn = document.getElementById('useBooster');
    const dailyRewardBtn = document.getElementById('dailyReward');

    // Store buttons
    const buyBoosterPackBtn = document.getElementById('buyBoosterPack');
    const removeAdsPaidBtn = document.getElementById('removeAdsPaidBtn');
    const buyGemsBtn = document.getElementById('buyGems');
    // Special collection buttons
    const buyAncientTomeBtn = document.getElementById('buyAncientTome');
    const buyMythicScrollBtn = document.getElementById('buyMythicScroll');
    const buyLegendaryCodexBtn = document.getElementById('buyLegendaryCodex');

    // New special item: infinite shelf
    const buyInfiniteShelfBtn = document.getElementById('buyInfiniteShelf');
    // Event button
    const startEventBtnEl = document.getElementById('startEventBtn');

    // Function to update display
    function updateDisplay() {
      // Display current counts with active multipliers from prestige and boosters
      // Compute total multiplier from prestige, boosters, special collections, and events
      const totalMultiplier = prestigeMultiplier * (boosterActive ? 2 : 1) * globalBonusMultiplier * (eventActive ? eventMultiplier : 1);
      coinsEl.textContent = Math.floor(coins).toLocaleString();
      clickValueEl.textContent = (clickValue * totalMultiplier).toFixed(1);
      passiveEl.textContent = (passiveIncome * totalMultiplier).toFixed(2);
      upgradeCostEl.textContent = upgradeCost.toFixed(0);
      workerCostEl.textContent = workerCost.toFixed(0);
      expandCostEl.textContent = expandRoomCost.toFixed(0);
      manuscriptCostEl.textContent = manuscriptCost.toFixed(0);

      digitizeCostEl.textContent = digitizeCost.toFixed(0);
      eventCostEl.textContent = eventCost.toFixed(0);
      wingCostEl.textContent = wingCost.toFixed(0);

      // Update special collection costs
      const ancientSpan = document.getElementById('ancientTomeCost');
      if (ancientSpan) ancientSpan.textContent = specialItemCosts.ancientTome.toFixed(0);
      const mythicSpan = document.getElementById('mythicScrollCost');
      if (mythicSpan) mythicSpan.textContent = specialItemCosts.mythicScroll.toFixed(0);
      const legendarySpan = document.getElementById('legendaryCodexCost');
      if (legendarySpan) legendarySpan.textContent = specialItemCosts.legendaryCodex.toFixed(0);

      // Update cost display for the new Infinite Shelf item
      const infiniteShelfSpan = document.getElementById('infiniteShelfCost');
      if (infiniteShelfSpan) infiniteShelfSpan.textContent = specialItemCosts.infiniteShelf.toFixed(0);

      // Update gem display
      const gemEl = document.getElementById('gemCount');
      if (gemEl) gemEl.textContent = gems;

      // Update all‑time books display
      const totalBooksEl = document.getElementById('totalBooks');
      if (totalBooksEl) totalBooksEl.textContent = Math.floor(totalBooks).toLocaleString();

      // check for achievements after updating display
      checkAchievements();
      // Update progress bar even if no achievement unlocked
      updateAchievementsList();

      // Track book collection for quests
      trackBookCollection();

      // Update leaderboard ranking
      updateLeaderboard();
      // Global leaderboard is now unified into the main leaderboard, so no
      // separate update is required here.

      // Update event status display
      updateEventStatus();

      // Update event button availability based on daily limit
      const eventBtn = document.getElementById('startEventBtn');
      if (eventBtn) {
        if (!eventActive && eventUsesToday >= maxEventUsesPerDay) {
          eventBtn.disabled = true;
          eventBtn.textContent = 'No festival passes left today';
        } else {
          eventBtn.disabled = false;
          eventBtn.textContent = 'Host Book Festival (5 min ×3 income)';
        }
      }

      // Update inventory display for special collections
      updateInventoryDisplay();

      // Update prestige button visibility and label
      if (coins >= prestigeThreshold) {
        prestigeBtn.style.display = 'block';
        prestigeBtn.textContent = `Renovate Library (Prestige x${prestigeLevel + 2})`;
      } else {
        prestigeBtn.style.display = 'none';
      }

      // Update booster and prestige displays
      document.getElementById('prestigeDisplay').textContent = prestigeLevel;
      document.getElementById('boosterCount').textContent = boosterCount;

      // Update daily reward button state
      const now = Date.now();
      if (now - lastDailyRewardTime >= 24 * 60 * 60 * 1000) {
        dailyRewardBtn.disabled = false;
        dailyRewardBtn.textContent = 'Claim Daily Reward';
      } else {
        dailyRewardBtn.disabled = true;
        const nextClaim = 24 * 60 * 60 * 1000 - (now - lastDailyRewardTime);
        const hours = Math.floor(nextClaim / 3600000);
        const minutes = Math.floor((nextClaim % 3600000) / 60000);
        dailyRewardBtn.textContent = `Next reward in ${hours}h ${minutes}m`;
      }

      // Update booster button when active
      if (boosterActive) {
        const remaining = Math.max(0, Math.floor((boosterEndTime - now) / 1000));
        useBoosterBtn.disabled = true;
        useBoosterBtn.textContent = `Booster Active (${remaining}s)`;
      } else {
        useBoosterBtn.disabled = boosterCount === 0;
        useBoosterBtn.textContent = 'Use Booster (x2 for 2m)';
      }

      // Check if we need to reset event uses for a new day
      checkEventReset();
    }

    // Add books when cataloging
    clickBtn.addEventListener('click', () => {
      playPageTurn();
      /*
       * Compute the click gain based on the value shown to the player.
       * Rather than recalculating clickValue * multipliers separately, we
       * parse the displayed "books per tap" value. This avoids any mismatch
       * between the number shown in the UI and the actual books awarded and
       * ensures the player always receives exactly what they see.
       */
      const gain = parseFloat(clickValueEl.textContent);
      coins += gain;
      totalBooks += gain;
      // Trigger bounce animation on book icon
      const icon = document.getElementById('bookIcon');
      if (icon) {
        icon.classList.add('image-animate');
        icon.addEventListener('animationend', () => {
          icon.classList.remove('image-animate');
        }, { once: true });
      }
      updateDisplay();
    });

    // Improve cataloging tools to increase books per tap
    upgradeClickBtn.addEventListener('click', () => {
      if (coins >= upgradeCost) {
        playPageTurn();
        coins -= upgradeCost;
        clickValue += 1;
        upgradeCost = Math.floor(upgradeCost * 1.5);
        log('Improved cataloging! Books per tap: ' + clickValue);
        updateDisplay();
      } else {
        log('Not enough books to improve cataloging tools.');
      }
    });

    // Hire librarian to increase passive book collection
    hireWorkerBtn.addEventListener('click', () => {
      if (coins >= workerCost) {
        playPageTurn();
        coins -= workerCost;
        passiveIncome += 0.5;
        workerCost = Math.floor(workerCost * 1.75);
        log('Hired a librarian! Books per second: ' + passiveIncome);
        updateDisplay();

        // Update quest progress for hiring librarians
        updateQuestProgress('hireLibrarians', 1);
      } else {
        log('Not enough books to hire a librarian.');
      }
    });

    // Prestige button event
    prestigeBtn.addEventListener('click', () => {
      prestige();
    });

    // Watch ad for booster button
    boosterBtn.addEventListener('click', () => {
      playPageTurn();
      getBooster();
    });

    // Use booster button
    useBoosterBtn.addEventListener('click', () => {
      playPageTurn();
      useBooster();
    });

    // Daily reward button
    dailyRewardBtn.addEventListener('click', () => {
      playPageTurn();
      claimDailyReward();
    });

    // Store button events
    if (buyBoosterPackBtn) {
      buyBoosterPackBtn.addEventListener('click', () => {
        playPageTurn();
        purchaseBoosterPack();
      });
    }
    if (removeAdsPaidBtn) {
      removeAdsPaidBtn.addEventListener('click', () => {
        playPageTurn();
        purchaseRemoveAdsPaid();
      });
    }
    if (buyGemsBtn) {
      buyGemsBtn.addEventListener('click', () => {
        playPageTurn();
        purchaseGems();
      });
    }
    // Special collections events
    if (buyAncientTomeBtn) {
      buyAncientTomeBtn.addEventListener('click', () => {
        playPageTurn();
        buySpecialItem('ancientTome');
      });
    }
    if (buyMythicScrollBtn) {
      buyMythicScrollBtn.addEventListener('click', () => {
        playPageTurn();
        buySpecialItem('mythicScroll');
      });
    }
    if (buyLegendaryCodexBtn) {
      buyLegendaryCodexBtn.addEventListener('click', () => {
        playPageTurn();
        buySpecialItem('legendaryCodex');
      });
    }

    if (buyInfiniteShelfBtn) {
      buyInfiniteShelfBtn.addEventListener('click', () => {
        playPageTurn();
        buySpecialItem('infiniteShelf');
      });
    }
    // Event button
    if (startEventBtnEl) {
      startEventBtnEl.addEventListener('click', () => {
        playPageTurn();
        startEvent();
      });
    }

    // Remove ads button (placeholder)
    // Note: The legacy `removeAdsBtn` element no longer exists now that the
    // store uses `removeAdsPaidBtn`. Accessing a null element would cause an
    // error, so we simply remove this unused listener. The purchase logic
    // remains wired to `removeAdsPaidBtn` above.
    // const removeAdsBtn = document.getElementById('removeAdsBtn');
    // if (removeAdsBtn) {
    //   removeAdsBtn.addEventListener('click', () => {
    //     log('In-app purchases are not implemented in this prototype.');
    //   });
    // }

    // Add friend button
    addFriendBtn.addEventListener('click', () => {
      addFriend(friendCodeInput.value);
      friendCodeInput.value = '';
    });

    // Expand reading room to significantly increase passive income
    expandRoomBtn.addEventListener('click', () => {
      if (coins >= expandRoomCost) {
        playPageTurn();
        coins -= expandRoomCost;
        passiveIncome += 1;
        expandRoomCost = Math.floor(expandRoomCost * 1.7);
        log('Expanded the reading room! Books per second: ' + passiveIncome);
        updateDisplay();
      } else {
        log('Not enough books to expand the reading room.');
      }
    });

    // Acquire rare manuscripts to boost books per tap
    buyManuscriptBtn.addEventListener('click', () => {
      if (coins >= manuscriptCost) {
        playPageTurn();
        coins -= manuscriptCost;
        clickValue += 3;
        manuscriptCost = Math.floor(manuscriptCost * 1.8);
        log('Acquired rare manuscripts! Books per tap: ' + clickValue);
        updateDisplay();
      } else {
        log('Not enough books to acquire rare manuscripts.');
      }
    });

    // Digitize archives to greatly boost books per tap
    digitizeBtn.addEventListener('click', () => {
      if (coins >= digitizeCost) {
        playPageTurn();
        coins -= digitizeCost;
        clickValue += 5;
        digitizeCost = Math.floor(digitizeCost * 1.8);
        log('Digitized the archives! Books per tap: ' + clickValue);
        updateDisplay();
      } else {
        log('Not enough books to digitize the archives.');
      }
    });

    // Host author event to increase passive income
    hostEventBtn.addEventListener('click', () => {
      if (coins >= eventCost) {
        playPageTurn();
        coins -= eventCost;
        passiveIncome += 2;
        eventCost = Math.floor(eventCost * 1.7);
        log('Hosted an author event! Books per second: ' + passiveIncome.toFixed(1));
        updateDisplay();
      } else {
        log('Not enough books to host an author event.');
      }
    });

    // Open a new wing: boosts both click and passive income
    openWingBtn.addEventListener('click', () => {
      if (coins >= wingCost) {
        playPageTurn();
        coins -= wingCost;
        clickValue += 2;
        passiveIncome += 3;
        wingCost = Math.floor(wingCost * 2);
        log('Opened a new wing! Books per tap: ' + clickValue + ', books per second: ' + passiveIncome.toFixed(1));
        updateDisplay();
      } else {
        log('Not enough books to open a new wing.');
      }
    });

    // Page-turn sound generator using Web Audio API
    // global audio context to reuse for multiple sounds
    const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
    /**
     * Play a page-turn style sound.
     * This synthesizes a short burst of filtered noise with a quick fade-out
     * to emulate the rustle of paper. The sound is generated procedurally so
     * there is no need to download external audio files.
     */
    function playPageTurn() {
      if (!audioCtx) return;
      // We synthesize a gentle page-turn by combining filtered noise with a short
      // frequency sweep. The noise provides the rustling texture while the
      // oscillator adds a soft flick.
      const now = audioCtx.currentTime;
      const duration = 0.3;
      // Create noise buffer with an exponential decay
      const sampleRate = audioCtx.sampleRate;
      const bufferSize = Math.floor(sampleRate * duration);
      const buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        // Exponential fade-out to smooth the tail
        const env = Math.exp(-5 * i / bufferSize);
        data[i] = (Math.random() * 2 - 1) * env * 0.4;
      }
      const noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = buffer;
      // Bandpass filter to focus on mid‑high frequencies typical of page rustle
      const bandpass = audioCtx.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.setValueAtTime(900, now);
      bandpass.Q.value = 0.6;
      // Gain envelope for noise (softer volume)
      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.18, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
      noiseSource.connect(bandpass).connect(noiseGain).connect(audioCtx.destination);
      // Oscillator for a soft sweep – adds a gentle flick to the sound
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(900, now);
      osc.frequency.exponentialRampToValueAtTime(300, now + 0.2);
      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.1, now);
      oscGain.gain.exponentialRampToValueAtTime(0.005, now + 0.3);
      osc.connect(oscGain).connect(audioCtx.destination);
      // Start and stop sources
      noiseSource.start(now);
      osc.start(now);
      noiseSource.stop(now + duration);
      osc.stop(now + 0.3);
    }

    // Check and unlock achievements
    function checkAchievements() {
      achievementsData.forEach((ach) => {
        if (!ach.unlocked && coins >= ach.threshold) {
          ach.unlocked = true;
          log('Achievement unlocked: ' + ach.name + '!');
          playPageTurn();
          updateAchievementsList();
        }
      });
    }

    // Update the displayed achievements list
    function updateAchievementsList() {
      // Clear list
      achievementsListEl.innerHTML = '';
      achievementsData.forEach((ach) => {
        const li = document.createElement('li');
        // Compose text with name and description so players know the requirement
        const icon = ach.unlocked ? '✔️' : '❌';
        // Use strong tag for name when unlocked
        if (ach.unlocked) {
          li.innerHTML = `${icon} <strong>${ach.name}</strong> — ${ach.description}`;
          li.className = 'achievement-unlocked';
        } else {
          // For locked achievements, grey out the text but still show description
          li.innerHTML = `${icon} <span>${ach.name}</span> — ${ach.description}`;
          li.className = 'achievement-locked';
        }
        achievementsListEl.appendChild(li);
      });

      // Update progress bar: find next locked achievement threshold
      const nextAch = achievementsData.find(a => !a.unlocked);
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      if (nextAch) {
        // Calculate ratio of current coins to threshold
        const ratio = Math.min(coins / nextAch.threshold, 1);
        progressBar.style.width = (ratio * 100).toFixed(0) + '%';
        progressText.textContent = `Progress to next achievement (${nextAch.name}): ${(ratio * 100).toFixed(0)}%`;
      } else {
        // All achievements unlocked; set bar full
        progressBar.style.width = '100%';
        progressText.textContent = 'All achievements unlocked!';
      }
    }

    // Passive income generator
    setInterval(() => {
      // Determine multiplier from prestige, boosters, special collections, and events
      const multiplier = prestigeMultiplier * (boosterActive ? 2 : 1) * globalBonusMultiplier * (eventActive ? eventMultiplier : 1);
      const passiveGain = (passiveIncome * multiplier) / 10;
      coins += passiveGain;
      totalBooks += passiveGain;
      updateDisplay();
      // Check booster expiry
      if (boosterActive && Date.now() >= boosterEndTime) {
        boosterActive = false;
        log('Booster ended.');
      }
      // Check event expiry
      if (eventActive && Date.now() >= eventEndTime) {
        eventActive = false;
        log('The Book Festival has ended.');
      }
    }, 100);

    /**
     * Prestige/reset function. When the player has enough books, they can
     * renovate the library. This resets their currency and upgrades but
     * permanently increases their earnings through a multiplier. This mechanic
     * encourages long‑term progression by offering exponential growth and
     * replayability【973594451637787†L124-L154】.
     */
    function prestige() {
      if (coins < prestigeThreshold) return;
      // Calculate prestige multiplier: each prestige increases multiplier by 2x
      prestigeLevel++;
      prestigeMultiplier = Math.pow(2, prestigeLevel);
      // Reset game state to initial values
      coins = 0;
      clickValue = 1;
      passiveIncome = 0;
      upgradeCost = 10;
      workerCost = 25;
      expandRoomCost = 50;
      manuscriptCost = 30;
      digitizeCost = 100;
      eventCost = 150;
      wingCost = 250;
      // Reset achievements unlocked flags? We keep achievements; they persist.
      log(`Library renovated! Prestige level is now ${prestigeLevel}. Earnings are multiplied.`);
      updateDisplay();
    }

    /**
     * Simulate watching a rewarded ad to earn a booster. In commercial
     * implementations, this would play a video ad and, upon completion,
     * increment the booster count. Here we simply increment the count and
     * provide feedback to the player.
     */
    function getBooster() {
      // Show a rewarded ad. When the ad finishes, grant a booster.
      showRewardedAd().then(watched => {
        if (watched) {
          boosterCount++;
          log('You watched an ad and earned a booster!');
          updateDisplay();
        } else {
          log('Ad failed or was skipped. No booster awarded.');
        }
      });
    }

    /**
     * Activate a booster if available. Boosters double earnings for a limited
     * duration. While active, the useBooster button shows the remaining
     * time and is disabled.
     */
    function useBooster() {
      if (boosterActive || boosterCount <= 0) return;
      boosterCount--;
      boosterActive = true;
      boosterEndTime = Date.now() + boosterDuration * 1000;
      log('Booster activated! Earnings doubled for 2 minutes.');
      updateDisplay();
    }

    /**
     * Claim a daily login reward. If 24 hours have passed since the last
     * claim, the player receives additional books. This feature encourages
     * players to return regularly【973594451637787†L189-L223】.
     */
    function claimDailyReward() {
      const now = Date.now();
      if (now - lastDailyRewardTime < 24 * 60 * 60 * 1000) {
        return;
      }
      lastDailyRewardTime = now;
      // Reward scales with prestige level
      const reward = dailyRewardAmount * (prestigeLevel + 1);
      coins += reward;
      totalBooks += reward;
      log(`Daily reward claimed! You received ${reward} books.`);
      updateDisplay();
    }

    /**
     * Compute and apply offline earnings. When the game is loaded, we
     * calculate how much time has passed since the last save and grant
     * passive income accordingly, up to a cap. This imitates the capped
     * offline rewards used by top idle games to encourage frequent return
     * sessions【119958854742217†L105-L109】.
     */
    function applyOfflineEarnings() {
      const now = Date.now();
      if (!lastSaveTime) {
        lastSaveTime = now;
        return;
      }
      const elapsedMs = now - lastSaveTime;
      const elapsedHours = elapsedMs / 3600000;
      // Cap offline earnings to 8 hours to avoid collecting too much
      const cappedHours = Math.min(elapsedHours, 8);
      // Use current passive income (before prestige/booster multipliers) for offline earnings
      // Include global bonus multiplier but not boosters or events for offline gains
      const offlineGain = passiveIncome * prestigeMultiplier * globalBonusMultiplier * cappedHours * 3600;
      if (offlineGain > 0.1) {
        coins += offlineGain;
        totalBooks += offlineGain;
        log(`While you were away, your librarians gathered ${offlineGain.toFixed(0)} books.`);
      }
      lastSaveTime = now;
    }

    /**
     * Initialize daily quests. Resets quests every 24 hours or loads saved
     * progress. Quests encourage players to complete specific actions and
     * provide extra rewards, similar to daily missions in many idle games
     *【973594451637787†L189-L223】.
     */
    function initDailyQuests() {
      const now = Date.now();
      // If it's been more than 24h since last reset, generate new quests
      if (!lastQuestResetTime || now - lastQuestResetTime >= 24 * 60 * 60 * 1000) {
        resetDailyQuests();
        lastQuestResetTime = now;
      }
      // Ensure lastQuestCoins starts at current coin count
      lastQuestCoins = coins;
      updateQuestsDisplay();
    }

    function resetDailyQuests() {
      dailyQuests = [
        { id: 1, type: 'collectBooks', amount: 1000, progress: 0, reward: 150, description: 'Collect 1,000 books', completed: false, claimed: false },
        { id: 2, type: 'hireLibrarians', amount: 3, progress: 0, reward: 200, description: 'Hire 3 librarians', completed: false, claimed: false }
      ];
      log('New daily quests are available!');
    }

    // Update quests progress based on actions
    function updateQuestProgress(type, increment = 1) {
      dailyQuests.forEach(quest => {
        if (!quest.completed && quest.type === type) {
          quest.progress += increment;
          if (quest.progress >= quest.amount) {
            quest.completed = true;
            log(`Quest complete: ${quest.description}`);
          }
        }
      });
      updateQuestsDisplay();
    }

    // Special function for collecting books: calculates difference in coins since last update
    function trackBookCollection() {
      const gained = coins - lastQuestCoins;
      if (gained > 0) {
        updateQuestProgress('collectBooks', gained);
        lastQuestCoins = coins;
      }
    }

    function claimQuest(id) {
      const quest = dailyQuests.find(q => q.id === id);
      if (quest && quest.completed && !quest.claimed) {
        quest.claimed = true;
        coins += quest.reward;
        totalBooks += quest.reward;
        log(`Quest reward claimed: +${quest.reward} books.`);
        updateQuestsDisplay();
        updateDisplay();
      }
    }

    function updateQuestsDisplay() {
      questsListEl.innerHTML = '';
      dailyQuests.forEach(quest => {
        const li = document.createElement('li');
        li.className = 'quest-item';
        // Create description text
        const span = document.createElement('span');
        span.textContent = `${quest.description}`;
        li.appendChild(span);
        // Progress bar
        const progressContainer = document.createElement('div');
        progressContainer.className = 'quest-progress-container';
        const progressBar = document.createElement('div');
        progressBar.className = 'quest-progress-bar';
        const ratio = Math.min(quest.progress / quest.amount, 1);
        progressBar.style.width = (ratio * 100).toFixed(0) + '%';
        progressContainer.appendChild(progressBar);
        li.appendChild(progressContainer);
        // Reward or claim button
        const rewardSpan = document.createElement('span');
        rewardSpan.style.marginLeft = '6px';
        rewardSpan.textContent = `Reward: ${quest.reward}`;
        li.appendChild(rewardSpan);
        if (quest.completed && !quest.claimed) {
          const claimBtn = document.createElement('button');
          claimBtn.textContent = 'Claim';
          claimBtn.addEventListener('click', () => claimQuest(quest.id));
          li.appendChild(claimBtn);
        } else if (quest.claimed) {
          const doneSpan = document.createElement('span');
          doneSpan.textContent = ' (Claimed)';
          doneSpan.style.color = '#2c7a7b';
          li.appendChild(doneSpan);
        }
        questsListEl.appendChild(li);
      });
    }

    /**
     * Initialize and display theme options. Themes allow players to customize
     * the look of their library. Some themes require spending books to unlock.
     */
    function initThemes() {
      themesOptionsEl.innerHTML = '';
      Object.keys(themes).forEach(key => {
        const theme = themes[key];
        const div = document.createElement('div');
        div.className = 'theme-option';
        if (!ownedThemes[key]) {
          div.classList.add('disabled');
        }
        const label = document.createElement('span');
        label.textContent = `${theme.name}`;
        div.appendChild(label);
        const button = document.createElement('button');
        if (ownedThemes[key]) {
          button.textContent = currentTheme === key ? 'Selected' : 'Select';
          button.disabled = currentTheme === key;
        } else {
          // Show cost in gems or coins depending on theme settings
          if (theme.gemsCost && theme.gemsCost > 0) {
            button.textContent = `Buy (${theme.gemsCost} gems)`;
          } else {
            button.textContent = `Buy (${theme.cost})`;
          }
        }
        button.addEventListener('click', () => {
          changeTheme(key);
        });
        div.appendChild(button);
        themesOptionsEl.appendChild(div);
      });
      applyTheme();
    }

    function changeTheme(key) {
      const theme = themes[key];
      if (!ownedThemes[key]) {
        // Attempt to purchase theme using gems if specified, otherwise books
        if (theme.gemsCost && theme.gemsCost > 0) {
          if (gems >= theme.gemsCost) {
            gems -= theme.gemsCost;
            ownedThemes[key] = true;
            log(`You purchased the ${theme.name} theme with gems.`);
          } else {
            log('Not enough gems to purchase this theme.');
            return;
          }
        } else {
          if (coins >= theme.cost) {
            coins -= theme.cost;
            ownedThemes[key] = true;
            log(`You purchased the ${theme.name} theme.`);
          } else {
            log('Not enough books to purchase this theme.');
            return;
          }
        }
      }
      currentTheme = key;
      log(`Theme switched to ${theme.name}.`);
      initThemes();
      updateDisplay();
    }

    function applyTheme() {
      const theme = themes[currentTheme];
      // Set body background image
      document.body.style.backgroundImage = `url('${theme.bg}')`;
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center';
      document.body.style.backgroundAttachment = 'fixed';
      // Set container background and text colors
      const gameContainer = document.getElementById('gameContainer');
      if (gameContainer) {
        gameContainer.style.backgroundColor = theme.containerBg;
        gameContainer.style.color = theme.textColor;
      }
      // Update accent colors for progress bars
      const bars = document.querySelectorAll('#progressBar, .quest-progress-bar');
      bars.forEach(bar => {
        bar.style.backgroundColor = theme.accentColor;
      });
    }

    /**
     * Update the leaderboard display. This is a static placeholder that
     * compares the player’s books to other fictitious players. It gives
     * players a sense of progress relative to a community【973594451637787†L189-L223】.
     */
    function updateLeaderboard() {
      // Compose combined leaderboard: player + global competitors + friends
      const combined = [];
      // Player entry (use all‑time books collected)
      combined.push({ name: 'You', score: Math.floor(totalBooks) });
      // Global competitors
      globalPlayers.forEach(entry => {
        combined.push({ name: entry.name, score: entry.score });
      });
      // Friends
      friendsList.forEach(friend => {
        combined.push({ name: friend.name, score: friend.score });
      });
      // Sort descending by score
      combined.sort((a, b) => b.score - a.score);
      // Render list
      leaderboardListEl.innerHTML = '';
      combined.forEach(entry => {
        const li = document.createElement('li');
        li.textContent = `${entry.name}: ${entry.score.toLocaleString()} books`;
        if (entry.name === 'You') {
          li.style.fontWeight = 'bold';
          li.style.color = '#6c63ff';
        }
        leaderboardListEl.appendChild(li);
      });
    }

    // The global leaderboard display has been removed. The global players are
    // merged into the main leaderboard via updateLeaderboard().

    /**
     * Start simulating global competitor updates. This periodically increases
     * the scores of fictitious players to emulate ongoing competition. These
     * scores feed into the unified leaderboard.
     */
    function startLeaderboardSimulation() {
      setInterval(() => {
        globalPlayers.forEach((entry, idx) => {
          // Increase each competitor by a random amount based on their rank
          const factor = 1 + (idx / globalPlayers.length);
          entry.score += Math.floor(Math.random() * 3000 * factor);
        });
        // Refresh leaderboard display to reflect new competitor scores
        updateLeaderboard();
      }, 7000);
    }

    /**
     * Purchase a booster pack via the store. Adds multiple boosters to the
     * player's inventory. In a real implementation this would verify a
     * purchase via the platform's payment API and only then grant items.
     */
    function purchaseBoosterPack() {
      // Trigger a real in‑app purchase process. In a live app you would
      // integrate with Google Play Billing or Apple IAP here. For now we
      // simply simulate success.
      processIAP('booster_pack').then(success => {
        if (success) {
          boosterCount += 5;
          log('Booster pack purchased! You received 5 boosters.');
          updateDisplay();
        } else {
          log('Purchase failed.');
        }
      });
    }

    /**
     * Purchase the ad removal. Once purchased, the watch‑ad button is hidden
     * and the player sees no more ads. This sets a flag but does not process
     * real payments in this prototype.
     */
    function purchaseRemoveAdsPaid() {
      if (removeAdsPurchased) {
        log('Ads have already been removed.');
        return;
      }
      // In a live app, initiate an IAP for removing ads. After success,
      // update the state and hide ad buttons.
      processIAP('remove_ads').then(success => {
        if (success) {
          removeAdsPurchased = true;
          if (boosterBtn) boosterBtn.style.display = 'none';
          if (removeAdsPaidBtn) removeAdsPaidBtn.style.display = 'none';
          log('Ads removed! Thank you for your purchase.');
          updateDisplay();
        } else {
          log('Purchase failed.');
        }
      });
    }

    /**
     * Purchase a gem pack. Gems could be spent on cosmetics or special
     * collections. In this prototype, they simply accumulate.
     */
    function purchaseGems() {
      // Purchase gems using the payment SDK. The success callback grants gems.
      processIAP('gems_pack').then(success => {
        if (success) {
          gems += 100;
          log('Gem pack purchased! You received 100 gems.');
          updateDisplay();
        } else {
          log('Purchase failed.');
        }
      });
    }

    /**
     * Buy a special collection item. Each item multiplies global earnings and
     * increases in cost after each purchase. This provides late‑game goals
     * and exponential growth opportunities.
     */
    function buySpecialItem(key) {
      const cost = specialItemCosts[key];
      if (coins < cost) {
        log('Not enough books to acquire this special collection.');
        return;
      }
      coins -= cost;
      specialItemCounts[key]++;
      globalBonusMultiplier *= specialItemMultipliers[key];
      // Increase cost: each purchase makes the next significantly more expensive.
      // Different items scale at different rates to reflect their rarity.
      let scale;
      if (key === 'ancientTome') {
        scale = 2;
      } else if (key === 'mythicScroll') {
        scale = 2.5;
      } else if (key === 'legendaryCodex') {
        scale = 3;
      } else if (key === 'infiniteShelf') {
        // Infinite Shelf is extremely powerful, so its cost grows faster
        scale = 4;
      } else {
        scale = 2;
      }
      specialItemCosts[key] = Math.floor(cost * scale);
      // Determine a human‑readable name for the log message
      let itemName;
      if (key === 'ancientTome') {
        itemName = 'Ancient Tome';
      } else if (key === 'mythicScroll') {
        itemName = 'Mythic Scroll';
      } else if (key === 'legendaryCodex') {
        itemName = 'Legendary Codex';
      } else if (key === 'infiniteShelf') {
        itemName = 'Infinite Shelf';
      } else {
        itemName = key;
      }
      log(`You acquired a ${itemName}! Global income increased.`);
      updateDisplay();
    }

    /**
     * Start a limited‑time event. Only one event can run at a time. Events
     * multiply earnings for a fixed duration. When the event ends, the
     * multiplier resets.
     */
    function startEvent() {
      // Check if event is already active
      if (eventActive) {
        log('An event is already active.');
        return;
      }
      // Check if the daily limit has been reached
      if (eventUsesToday >= maxEventUsesPerDay) {
        log('No more festival passes available today.');
        return;
      }
      eventActive = true;
      eventEndTime = Date.now() + eventDuration * 1000;
      eventUsesToday++;
      log('The Book Festival has started! Your income is tripled for 5 minutes.');
      updateDisplay();
    }

    /**
     * Reset event usage daily. If more than 24 hours have passed since
     * lastEventResetTime, reset eventUsesToday and update the timestamp.
     */
    function checkEventReset() {
      const now = Date.now();
      if (!lastEventResetTime) {
        lastEventResetTime = now;
        return;
      }
      if (now - lastEventResetTime >= 24 * 60 * 60 * 1000) {
        eventUsesToday = 0;
        lastEventResetTime = now;
      }
    }

    /**
     * Update the event status display. This runs periodically to show the
     * remaining time or indicate that no event is active.
     */
    function updateEventStatus() {
      const statusEl = document.getElementById('eventStatus');
      if (!statusEl) return;
      if (eventActive) {
        const remaining = Math.max(0, Math.floor((eventEndTime - Date.now()) / 1000));
        const minutes = Math.floor(remaining / 60);
        const seconds = remaining % 60;
        statusEl.textContent = `Book Festival active: ${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
      } else {
        statusEl.textContent = 'No event active.';
      }
    }

    /**
     * Update the inventory display to show how many special collection items
     * the player owns. This provides a visual record of progression.
     */
    function updateInventoryDisplay() {
      const list = document.getElementById('inventoryList');
      if (!list) return;
      list.innerHTML = '';
      const entries = [
        { key: 'ancientTome', label: 'Ancient Tome' },
        { key: 'mythicScroll', label: 'Mythic Scroll' },
        { key: 'legendaryCodex', label: 'Legendary Codex' },
        // New end‑game item
        { key: 'infiniteShelf', label: 'Infinite Shelf' }
      ];
      entries.forEach(item => {
        const li = document.createElement('li');
        const count = specialItemCounts[item.key] || 0;
        li.textContent = `${item.label}: ${count}`;
        list.appendChild(li);
      });
    }

    /**
     * Generate a random player code. This could be used in a real game to
     * identify players for social interactions. Here it generates a short
     * alphanumeric code.
     */
    function generatePlayerCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = '';
      for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }

    function updatePlayerCodeDisplay() {
      if (playerCodeEl) {
        playerCodeEl.textContent = playerCode;
      }
    }

    function addFriend(code) {
      code = code.trim().toUpperCase();
      if (!code || code === playerCode) {
        log('Invalid friend code.');
        return;
      }
      // Check if friend already exists
      if (friendsList.some(f => f.code === code)) {
        log('Friend already added.');
        return;
      }
      // Generate a random name and score for the friend
      const names = ['Ava', 'Max', 'Riley', 'Charlie', 'Sasha'];
      const name = names[Math.floor(Math.random() * names.length)] + ' (Friend)';
      const score = Math.floor(Math.random() * 40000) + 5000;
      const friend = { code, name, score };
      friendsList.push(friend);
      log(`Friend added: ${name}!`);
      updateLeaderboard();
    }

    // Logging function
    function log(message) {
      const p = document.createElement('p');
      p.textContent = message;
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    /**
     * Apply purchase flags on load. For example, if ads have been removed,
     * hide the watch‑ad and remove‑ads buttons. This ensures the UI reflects
     * previously purchased upgrades when the game is reloaded.
     */
    function applyPurchaseFlags() {
      if (removeAdsPurchased) {
        if (boosterBtn) boosterBtn.style.display = 'none';
        if (removeAdsPaidBtn) removeAdsPaidBtn.style.display = 'none';
      }
    }

    // Load saved progress from localStorage
    function loadProgress() {
      const saved = JSON.parse(localStorage.getItem('idleGameProgress'));
      if (saved) {
        coins = saved.coins ?? coins;
        clickValue = saved.clickValue ?? clickValue;
        passiveIncome = saved.passiveIncome ?? passiveIncome;
        upgradeCost = saved.upgradeCost ?? upgradeCost;
        workerCost = saved.workerCost ?? workerCost;
        expandRoomCost = saved.expandRoomCost ?? expandRoomCost;
        manuscriptCost = saved.manuscriptCost ?? manuscriptCost;
        digitizeCost = saved.digitizeCost ?? digitizeCost;
        eventCost = saved.eventCost ?? eventCost;
        wingCost = saved.wingCost ?? wingCost;
        prestigeLevel = saved.prestigeLevel ?? prestigeLevel;
        prestigeMultiplier = saved.prestigeMultiplier ?? prestigeMultiplier;
        boosterCount = saved.boosterCount ?? boosterCount;
        boosterActive = saved.boosterActive ?? boosterActive;
        boosterEndTime = saved.boosterEndTime ?? boosterEndTime;
        lastDailyRewardTime = saved.lastDailyRewardTime ?? lastDailyRewardTime;
        lastSaveTime = saved.lastSaveTime ?? lastSaveTime;
        if (saved.achievements) {
          achievementsData.forEach((ach, index) => {
            ach.unlocked = saved.achievements[index] || ach.unlocked;
          });
        }
        // Load daily quests progress
        if (saved.dailyQuests) {
          dailyQuests = saved.dailyQuests;
        }
        lastQuestResetTime = saved.lastQuestResetTime ?? lastQuestResetTime;
        lastQuestCoins = saved.lastQuestCoins ?? coins;
        // Load themes
        ownedThemes = saved.ownedThemes ?? ownedThemes;
        currentTheme = saved.currentTheme ?? currentTheme;
        // Load social data
        playerCode = saved.playerCode ?? playerCode;
        friendsList = saved.friendsList ?? friendsList;
        // Load premium currency and purchase flags
        gems = saved.gems ?? gems;
        removeAdsPurchased = saved.removeAdsPurchased ?? removeAdsPurchased;
        // Load global bonus multiplier and special collections
        globalBonusMultiplier = saved.globalBonusMultiplier ?? globalBonusMultiplier;
        if (saved.specialItemCounts) {
          Object.keys(saved.specialItemCounts).forEach(key => {
            if (specialItemCounts.hasOwnProperty(key)) {
              specialItemCounts[key] = saved.specialItemCounts[key];
            }
          });
        }
        if (saved.specialItemCosts) {
          Object.keys(saved.specialItemCosts).forEach(key => {
            if (specialItemCosts.hasOwnProperty(key)) {
              specialItemCosts[key] = saved.specialItemCosts[key];
            }
          });
        }
        // Load event state
        eventActive = saved.eventActive ?? eventActive;
        eventEndTime = saved.eventEndTime ?? eventEndTime;

        // Load event usage count and reset time
        eventUsesToday = saved.eventUsesToday ?? eventUsesToday;
        lastEventResetTime = saved.lastEventResetTime ?? lastEventResetTime;

        // Load total books collected (all‑time)
        totalBooks = saved.totalBooks ?? totalBooks;
      }
    }

    // Save progress to localStorage periodically
    setInterval(() => {
      const progress = {
        coins,
        clickValue,
        passiveIncome,
        upgradeCost,
        workerCost,
        expandRoomCost,
        manuscriptCost,
        digitizeCost,
        eventCost,
        wingCost,
        achievements: achievementsData.map(ach => ach.unlocked),
        prestigeLevel,
        prestigeMultiplier,
        boosterCount,
        boosterActive,
        boosterEndTime,
        lastDailyRewardTime,
        lastSaveTime: Date.now(),
        dailyQuests,
        lastQuestResetTime,
        lastQuestCoins,
        ownedThemes,
        currentTheme,
        playerCode,
        friendsList,
        // Save premium currency and purchases
        gems,
        removeAdsPurchased,
        globalBonusMultiplier,
        specialItemCounts,
        specialItemCosts,
        eventActive,
        eventEndTime,
        eventUsesToday,
        lastEventResetTime,
        totalBooks
      };
      localStorage.setItem('idleGameProgress', JSON.stringify(progress));
    }, 2000);

    // Initialize
    loadProgress();
    applyOfflineEarnings();
    // Initialize achievements list display based on loaded progress
    updateAchievementsList();
    updateDisplay();

    // Initialize quests, themes, and leaderboard after loading
    initDailyQuests();
    initThemes();
    updateLeaderboard();

    // Apply purchase flags after loading (e.g., hide ad buttons)
    applyPurchaseFlags();

    // Initialize and start the unified leaderboard simulation
    // Note: The global leaderboard display is merged with the main leaderboard.
    startLeaderboardSimulation();

    // Start event status updater
    setInterval(updateEventStatus, 1000);

    // Initialize player code if needed and update display
    if (!playerCode) {
      playerCode = generatePlayerCode();
    }
    updatePlayerCodeDisplay();

    /**
     * Submit the player's score to a backend service. In production, this
     * would POST the player's code and all‑time score to a server such as
     * Firebase, PlayFab or a custom API. Without a backend, this stub
     * simply resolves true immediately.
     */
    async function submitScoreToServer() {
      try {
        // Example fetch call (commented out):
        // await fetch('https://your-backend.example.com/submit', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json' },
        //   body: JSON.stringify({ code: playerCode, score: Math.floor(totalBooks) })
        // });
        return true;
      } catch (e) {
        console.error('Error submitting score:', e);
        return false;
      }
    }

    /**
     * Fetch the global leaderboard from a backend service. In a live game
     * this would GET a list of top scores and names from a server. Here we
     * return a resolved promise because there is no backend available.
     */
    async function fetchLeaderboardFromServer() {
      try {
        // Example fetch call (commented out):
        // const response = await fetch('https://your-backend.example.com/leaderboard');
        // const data = await response.json();
        // globalPlayers = data.players;
        return true;
      } catch (e) {
        console.error('Error fetching leaderboard:', e);
        return false;
      }
    }

    /**
     * Simulate processing an in‑app purchase. In a real implementation, this
     * would invoke the Google Play Billing or Apple StoreKit APIs. The
     * promise resolves true to simulate a successful purchase.
     */
    function processIAP(productId) {
      return new Promise(resolve => {
        // Simulate network delay
        setTimeout(() => {
          // Always succeed in this prototype
          resolve(true);
        }, 1000);
      });
    }

    /**
     * Simulate showing a rewarded ad. In a production game, this function
     * would call an ad network SDK (e.g., Google AdMob, Unity Ads) and
     * return a promise that resolves true when the ad is watched to
     * completion. Here we simply wait a moment and resolve true.
     */
    function showRewardedAd() {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve(true);
        }, 500);
      });
    }

    // Hook score submission to save timer: periodically submit score to server
    setInterval(() => {
      submitScoreToServer();
    }, 15000);

    // Fetch leaderboard from server on load (no-op here)
    fetchLeaderboardFromServer();

    // Register service worker for PWA on supported browsers. This enables
    // offline play and allows the app to be installed like a native
    // mobile game when served over HTTPS. The service worker will be
    // registered once the page has fully loaded.
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(err => {
          console.error('ServiceWorker registration failed:', err);
        });
      });
    }
  </script>
</body>
</html>